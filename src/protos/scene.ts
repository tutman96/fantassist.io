// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.181.2
//   protoc               v3.21.12
// source: protos/scene.proto

/* eslint-disable */
import Long from "long";
import _m0 from "protobufjs/minimal";

export const protobufPackage = "";

export interface Scene {
  id: string;
  name: string;
  version: number;
  table: TableOptions | undefined;
  layers: Layer[];
}

export interface TableOptions {
  displayGrid: boolean;
  offset: Vector2d | undefined;
  rotation: number;
  scale: number;
}

export interface Vector2d {
  x: number;
  y: number;
}

export interface Size {
  width: number;
  height: number;
}

export interface Layer {
  assetLayer?: AssetLayer | undefined;
  fogLayer?: FogLayer | undefined;
  markerLayer?: MarkerLayer | undefined;
}

export enum Layer_LayerType {
  ASSETS = 0,
  FOG = 1,
  MARKERS = 2,
  UNRECOGNIZED = -1,
}

export function layer_LayerTypeFromJSON(object: any): Layer_LayerType {
  switch (object) {
    case 0:
    case "ASSETS":
      return Layer_LayerType.ASSETS;
    case 1:
    case "FOG":
      return Layer_LayerType.FOG;
    case 2:
    case "MARKERS":
      return Layer_LayerType.MARKERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return Layer_LayerType.UNRECOGNIZED;
  }
}

export function layer_LayerTypeToJSON(object: Layer_LayerType): string {
  switch (object) {
    case Layer_LayerType.ASSETS:
      return "ASSETS";
    case Layer_LayerType.FOG:
      return "FOG";
    case Layer_LayerType.MARKERS:
      return "MARKERS";
    case Layer_LayerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AssetLayer {
  id: string;
  name: string;
  visible: boolean;
  type: Layer_LayerType;
  assets: { [key: string]: AssetLayer_Asset };
}

export interface AssetLayer_AssetsEntry {
  key: string;
  value: AssetLayer_Asset | undefined;
}

export interface AssetLayer_Asset {
  id: string;
  type: AssetLayer_Asset_AssetType;
  size: Size | undefined;
  transform: AssetLayer_Asset_AssetTransform | undefined;
  calibration?: AssetLayer_Asset_AssetCalibration | undefined;
  snapToGrid?: boolean | undefined;
}

export enum AssetLayer_Asset_AssetType {
  IMAGE = 0,
  VIDEO = 1,
  UNRECOGNIZED = -1,
}

export function assetLayer_Asset_AssetTypeFromJSON(object: any): AssetLayer_Asset_AssetType {
  switch (object) {
    case 0:
    case "IMAGE":
      return AssetLayer_Asset_AssetType.IMAGE;
    case 1:
    case "VIDEO":
      return AssetLayer_Asset_AssetType.VIDEO;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AssetLayer_Asset_AssetType.UNRECOGNIZED;
  }
}

export function assetLayer_Asset_AssetTypeToJSON(object: AssetLayer_Asset_AssetType): string {
  switch (object) {
    case AssetLayer_Asset_AssetType.IMAGE:
      return "IMAGE";
    case AssetLayer_Asset_AssetType.VIDEO:
      return "VIDEO";
    case AssetLayer_Asset_AssetType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AssetLayer_Asset_AssetTransform {
  x: number;
  y: number;
  rotation: number;
  width: number;
  height: number;
}

export interface AssetLayer_Asset_AssetCalibration {
  xOffset: number;
  yOffset: number;
  ppiX: number;
  ppiY: number;
}

export interface FogLayer {
  id: string;
  name: string;
  visible: boolean;
  type: Layer_LayerType;
  lightSources: FogLayer_LightSource[];
  obstructionPolygons: FogLayer_Polygon[];
  fogPolygons: FogLayer_Polygon[];
  fogClearPolygons: FogLayer_Polygon[];
}

export interface FogLayer_LightSource {
  position: Vector2d | undefined;
  brightLightDistance: number;
  dimLightDistance: number;
  color: FogLayer_LightSource_Color | undefined;
}

export interface FogLayer_LightSource_Color {
  r: number;
  g: number;
  b: number;
  a: number;
}

export interface FogLayer_Polygon {
  type: FogLayer_Polygon_PolygonType;
  verticies: Vector2d[];
  visibleOnTable: boolean;
}

export enum FogLayer_Polygon_PolygonType {
  FOG = 0,
  FOG_CLEAR = 1,
  LIGHT_OBSTRUCTION = 2,
  UNRECOGNIZED = -1,
}

export function fogLayer_Polygon_PolygonTypeFromJSON(object: any): FogLayer_Polygon_PolygonType {
  switch (object) {
    case 0:
    case "FOG":
      return FogLayer_Polygon_PolygonType.FOG;
    case 1:
    case "FOG_CLEAR":
      return FogLayer_Polygon_PolygonType.FOG_CLEAR;
    case 2:
    case "LIGHT_OBSTRUCTION":
      return FogLayer_Polygon_PolygonType.LIGHT_OBSTRUCTION;
    case -1:
    case "UNRECOGNIZED":
    default:
      return FogLayer_Polygon_PolygonType.UNRECOGNIZED;
  }
}

export function fogLayer_Polygon_PolygonTypeToJSON(object: FogLayer_Polygon_PolygonType): string {
  switch (object) {
    case FogLayer_Polygon_PolygonType.FOG:
      return "FOG";
    case FogLayer_Polygon_PolygonType.FOG_CLEAR:
      return "FOG_CLEAR";
    case FogLayer_Polygon_PolygonType.LIGHT_OBSTRUCTION:
      return "LIGHT_OBSTRUCTION";
    case FogLayer_Polygon_PolygonType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface MarkerLayer {
  id: string;
  name: string;
  visible: boolean;
  type: Layer_LayerType;
  markers: Marker[];
}

export interface Marker {
  id: string;
  asset: AssetLayer_Asset | undefined;
}

export interface SceneExport {
  scene: Scene | undefined;
  files: SceneExport_File[];
}

export interface SceneExport_File {
  id: string;
  payload: Uint8Array;
  mediaType: string;
}

function createBaseScene(): Scene {
  return { id: "", name: "", version: 0, table: undefined, layers: [] };
}

export const Scene = {
  encode(message: Scene, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.version !== 0) {
      writer.uint32(24).uint64(message.version);
    }
    if (message.table !== undefined) {
      TableOptions.encode(message.table, writer.uint32(34).fork()).ldelim();
    }
    for (const v of message.layers) {
      Layer.encode(v!, writer.uint32(42).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Scene {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScene();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.version = longToNumber(reader.uint64() as Long);
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.table = TableOptions.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.layers.push(Layer.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Scene {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      version: isSet(object.version) ? globalThis.Number(object.version) : 0,
      table: isSet(object.table) ? TableOptions.fromJSON(object.table) : undefined,
      layers: globalThis.Array.isArray(object?.layers) ? object.layers.map((e: any) => Layer.fromJSON(e)) : [],
    };
  },

  toJSON(message: Scene): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.version !== 0) {
      obj.version = Math.round(message.version);
    }
    if (message.table !== undefined) {
      obj.table = TableOptions.toJSON(message.table);
    }
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => Layer.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Scene>, I>>(base?: I): Scene {
    return Scene.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Scene>, I>>(object: I): Scene {
    const message = createBaseScene();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.version = object.version ?? 0;
    message.table = (object.table !== undefined && object.table !== null)
      ? TableOptions.fromPartial(object.table)
      : undefined;
    message.layers = object.layers?.map((e) => Layer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTableOptions(): TableOptions {
  return { displayGrid: false, offset: undefined, rotation: 0, scale: 0 };
}

export const TableOptions = {
  encode(message: TableOptions, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.displayGrid !== false) {
      writer.uint32(8).bool(message.displayGrid);
    }
    if (message.offset !== undefined) {
      Vector2d.encode(message.offset, writer.uint32(18).fork()).ldelim();
    }
    if (message.rotation !== 0) {
      writer.uint32(25).double(message.rotation);
    }
    if (message.scale !== 0) {
      writer.uint32(33).double(message.scale);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): TableOptions {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTableOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.displayGrid = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.offset = Vector2d.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.rotation = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.scale = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TableOptions {
    return {
      displayGrid: isSet(object.displayGrid) ? globalThis.Boolean(object.displayGrid) : false,
      offset: isSet(object.offset) ? Vector2d.fromJSON(object.offset) : undefined,
      rotation: isSet(object.rotation) ? globalThis.Number(object.rotation) : 0,
      scale: isSet(object.scale) ? globalThis.Number(object.scale) : 0,
    };
  },

  toJSON(message: TableOptions): unknown {
    const obj: any = {};
    if (message.displayGrid !== false) {
      obj.displayGrid = message.displayGrid;
    }
    if (message.offset !== undefined) {
      obj.offset = Vector2d.toJSON(message.offset);
    }
    if (message.rotation !== 0) {
      obj.rotation = message.rotation;
    }
    if (message.scale !== 0) {
      obj.scale = message.scale;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TableOptions>, I>>(base?: I): TableOptions {
    return TableOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TableOptions>, I>>(object: I): TableOptions {
    const message = createBaseTableOptions();
    message.displayGrid = object.displayGrid ?? false;
    message.offset = (object.offset !== undefined && object.offset !== null)
      ? Vector2d.fromPartial(object.offset)
      : undefined;
    message.rotation = object.rotation ?? 0;
    message.scale = object.scale ?? 0;
    return message;
  },
};

function createBaseVector2d(): Vector2d {
  return { x: 0, y: 0 };
}

export const Vector2d = {
  encode(message: Vector2d, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Vector2d {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseVector2d();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Vector2d {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: Vector2d): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Vector2d>, I>>(base?: I): Vector2d {
    return Vector2d.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Vector2d>, I>>(object: I): Vector2d {
    const message = createBaseVector2d();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseSize(): Size {
  return { width: 0, height: 0 };
}

export const Size = {
  encode(message: Size, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.width !== 0) {
      writer.uint32(9).double(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(17).double(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Size {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSize();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.width = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.height = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Size {
    return {
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: Size): unknown {
    const obj: any = {};
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Size>, I>>(base?: I): Size {
    return Size.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Size>, I>>(object: I): Size {
    const message = createBaseSize();
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseLayer(): Layer {
  return { assetLayer: undefined, fogLayer: undefined, markerLayer: undefined };
}

export const Layer = {
  encode(message: Layer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.assetLayer !== undefined) {
      AssetLayer.encode(message.assetLayer, writer.uint32(10).fork()).ldelim();
    }
    if (message.fogLayer !== undefined) {
      FogLayer.encode(message.fogLayer, writer.uint32(18).fork()).ldelim();
    }
    if (message.markerLayer !== undefined) {
      MarkerLayer.encode(message.markerLayer, writer.uint32(26).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Layer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.assetLayer = AssetLayer.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.fogLayer = FogLayer.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.markerLayer = MarkerLayer.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Layer {
    return {
      assetLayer: isSet(object.assetLayer) ? AssetLayer.fromJSON(object.assetLayer) : undefined,
      fogLayer: isSet(object.fogLayer) ? FogLayer.fromJSON(object.fogLayer) : undefined,
      markerLayer: isSet(object.markerLayer) ? MarkerLayer.fromJSON(object.markerLayer) : undefined,
    };
  },

  toJSON(message: Layer): unknown {
    const obj: any = {};
    if (message.assetLayer !== undefined) {
      obj.assetLayer = AssetLayer.toJSON(message.assetLayer);
    }
    if (message.fogLayer !== undefined) {
      obj.fogLayer = FogLayer.toJSON(message.fogLayer);
    }
    if (message.markerLayer !== undefined) {
      obj.markerLayer = MarkerLayer.toJSON(message.markerLayer);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Layer>, I>>(base?: I): Layer {
    return Layer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Layer>, I>>(object: I): Layer {
    const message = createBaseLayer();
    message.assetLayer = (object.assetLayer !== undefined && object.assetLayer !== null)
      ? AssetLayer.fromPartial(object.assetLayer)
      : undefined;
    message.fogLayer = (object.fogLayer !== undefined && object.fogLayer !== null)
      ? FogLayer.fromPartial(object.fogLayer)
      : undefined;
    message.markerLayer = (object.markerLayer !== undefined && object.markerLayer !== null)
      ? MarkerLayer.fromPartial(object.markerLayer)
      : undefined;
    return message;
  },
};

function createBaseAssetLayer(): AssetLayer {
  return { id: "", name: "", visible: false, type: 0, assets: {} };
}

export const AssetLayer = {
  encode(message: AssetLayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.visible !== false) {
      writer.uint32(32).bool(message.visible);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    Object.entries(message.assets).forEach(([key, value]) => {
      AssetLayer_AssetsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).ldelim();
    });
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetLayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.visible = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          const entry6 = AssetLayer_AssetsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.assets[entry6.key] = entry6.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetLayer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      type: isSet(object.type) ? layer_LayerTypeFromJSON(object.type) : 0,
      assets: isObject(object.assets)
        ? Object.entries(object.assets).reduce<{ [key: string]: AssetLayer_Asset }>((acc, [key, value]) => {
          acc[key] = AssetLayer_Asset.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AssetLayer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.type !== 0) {
      obj.type = layer_LayerTypeToJSON(message.type);
    }
    if (message.assets) {
      const entries = Object.entries(message.assets);
      if (entries.length > 0) {
        obj.assets = {};
        entries.forEach(([k, v]) => {
          obj.assets[k] = AssetLayer_Asset.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLayer>, I>>(base?: I): AssetLayer {
    return AssetLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLayer>, I>>(object: I): AssetLayer {
    const message = createBaseAssetLayer();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.visible = object.visible ?? false;
    message.type = object.type ?? 0;
    message.assets = Object.entries(object.assets ?? {}).reduce<{ [key: string]: AssetLayer_Asset }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = AssetLayer_Asset.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseAssetLayer_AssetsEntry(): AssetLayer_AssetsEntry {
  return { key: "", value: undefined };
}

export const AssetLayer_AssetsEntry = {
  encode(message: AssetLayer_AssetsEntry, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      AssetLayer_Asset.encode(message.value, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetLayer_AssetsEntry {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetLayer_AssetsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = AssetLayer_Asset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetLayer_AssetsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? AssetLayer_Asset.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: AssetLayer_AssetsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = AssetLayer_Asset.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLayer_AssetsEntry>, I>>(base?: I): AssetLayer_AssetsEntry {
    return AssetLayer_AssetsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLayer_AssetsEntry>, I>>(object: I): AssetLayer_AssetsEntry {
    const message = createBaseAssetLayer_AssetsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? AssetLayer_Asset.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseAssetLayer_Asset(): AssetLayer_Asset {
  return { id: "", type: 0, size: undefined, transform: undefined, calibration: undefined, snapToGrid: undefined };
}

export const AssetLayer_Asset = {
  encode(message: AssetLayer_Asset, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.type !== 0) {
      writer.uint32(16).int32(message.type);
    }
    if (message.size !== undefined) {
      Size.encode(message.size, writer.uint32(26).fork()).ldelim();
    }
    if (message.transform !== undefined) {
      AssetLayer_Asset_AssetTransform.encode(message.transform, writer.uint32(34).fork()).ldelim();
    }
    if (message.calibration !== undefined) {
      AssetLayer_Asset_AssetCalibration.encode(message.calibration, writer.uint32(42).fork()).ldelim();
    }
    if (message.snapToGrid !== undefined) {
      writer.uint32(48).bool(message.snapToGrid);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetLayer_Asset {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetLayer_Asset();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.size = Size.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.transform = AssetLayer_Asset_AssetTransform.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.calibration = AssetLayer_Asset_AssetCalibration.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.snapToGrid = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetLayer_Asset {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      type: isSet(object.type) ? assetLayer_Asset_AssetTypeFromJSON(object.type) : 0,
      size: isSet(object.size) ? Size.fromJSON(object.size) : undefined,
      transform: isSet(object.transform) ? AssetLayer_Asset_AssetTransform.fromJSON(object.transform) : undefined,
      calibration: isSet(object.calibration)
        ? AssetLayer_Asset_AssetCalibration.fromJSON(object.calibration)
        : undefined,
      snapToGrid: isSet(object.snapToGrid) ? globalThis.Boolean(object.snapToGrid) : undefined,
    };
  },

  toJSON(message: AssetLayer_Asset): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.type !== 0) {
      obj.type = assetLayer_Asset_AssetTypeToJSON(message.type);
    }
    if (message.size !== undefined) {
      obj.size = Size.toJSON(message.size);
    }
    if (message.transform !== undefined) {
      obj.transform = AssetLayer_Asset_AssetTransform.toJSON(message.transform);
    }
    if (message.calibration !== undefined) {
      obj.calibration = AssetLayer_Asset_AssetCalibration.toJSON(message.calibration);
    }
    if (message.snapToGrid !== undefined) {
      obj.snapToGrid = message.snapToGrid;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLayer_Asset>, I>>(base?: I): AssetLayer_Asset {
    return AssetLayer_Asset.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLayer_Asset>, I>>(object: I): AssetLayer_Asset {
    const message = createBaseAssetLayer_Asset();
    message.id = object.id ?? "";
    message.type = object.type ?? 0;
    message.size = (object.size !== undefined && object.size !== null) ? Size.fromPartial(object.size) : undefined;
    message.transform = (object.transform !== undefined && object.transform !== null)
      ? AssetLayer_Asset_AssetTransform.fromPartial(object.transform)
      : undefined;
    message.calibration = (object.calibration !== undefined && object.calibration !== null)
      ? AssetLayer_Asset_AssetCalibration.fromPartial(object.calibration)
      : undefined;
    message.snapToGrid = object.snapToGrid ?? undefined;
    return message;
  },
};

function createBaseAssetLayer_Asset_AssetTransform(): AssetLayer_Asset_AssetTransform {
  return { x: 0, y: 0, rotation: 0, width: 0, height: 0 };
}

export const AssetLayer_Asset_AssetTransform = {
  encode(message: AssetLayer_Asset_AssetTransform, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    if (message.rotation !== 0) {
      writer.uint32(25).double(message.rotation);
    }
    if (message.width !== 0) {
      writer.uint32(33).double(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(41).double(message.height);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetLayer_Asset_AssetTransform {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetLayer_Asset_AssetTransform();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        case 2:
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        case 3:
          if (tag !== 25) {
            break;
          }

          message.rotation = reader.double();
          continue;
        case 4:
          if (tag !== 33) {
            break;
          }

          message.width = reader.double();
          continue;
        case 5:
          if (tag !== 41) {
            break;
          }

          message.height = reader.double();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetLayer_Asset_AssetTransform {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
      rotation: isSet(object.rotation) ? globalThis.Number(object.rotation) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: AssetLayer_Asset_AssetTransform): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    if (message.rotation !== 0) {
      obj.rotation = message.rotation;
    }
    if (message.width !== 0) {
      obj.width = message.width;
    }
    if (message.height !== 0) {
      obj.height = message.height;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLayer_Asset_AssetTransform>, I>>(base?: I): AssetLayer_Asset_AssetTransform {
    return AssetLayer_Asset_AssetTransform.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLayer_Asset_AssetTransform>, I>>(
    object: I,
  ): AssetLayer_Asset_AssetTransform {
    const message = createBaseAssetLayer_Asset_AssetTransform();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    message.rotation = object.rotation ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseAssetLayer_Asset_AssetCalibration(): AssetLayer_Asset_AssetCalibration {
  return { xOffset: 0, yOffset: 0, ppiX: 0, ppiY: 0 };
}

export const AssetLayer_Asset_AssetCalibration = {
  encode(message: AssetLayer_Asset_AssetCalibration, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.xOffset !== 0) {
      writer.uint32(13).float(message.xOffset);
    }
    if (message.yOffset !== 0) {
      writer.uint32(21).float(message.yOffset);
    }
    if (message.ppiX !== 0) {
      writer.uint32(29).float(message.ppiX);
    }
    if (message.ppiY !== 0) {
      writer.uint32(37).float(message.ppiY);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): AssetLayer_Asset_AssetCalibration {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssetLayer_Asset_AssetCalibration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 13) {
            break;
          }

          message.xOffset = reader.float();
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.yOffset = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.ppiX = reader.float();
          continue;
        case 4:
          if (tag !== 37) {
            break;
          }

          message.ppiY = reader.float();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssetLayer_Asset_AssetCalibration {
    return {
      xOffset: isSet(object.xOffset) ? globalThis.Number(object.xOffset) : 0,
      yOffset: isSet(object.yOffset) ? globalThis.Number(object.yOffset) : 0,
      ppiX: isSet(object.ppiX) ? globalThis.Number(object.ppiX) : 0,
      ppiY: isSet(object.ppiY) ? globalThis.Number(object.ppiY) : 0,
    };
  },

  toJSON(message: AssetLayer_Asset_AssetCalibration): unknown {
    const obj: any = {};
    if (message.xOffset !== 0) {
      obj.xOffset = message.xOffset;
    }
    if (message.yOffset !== 0) {
      obj.yOffset = message.yOffset;
    }
    if (message.ppiX !== 0) {
      obj.ppiX = message.ppiX;
    }
    if (message.ppiY !== 0) {
      obj.ppiY = message.ppiY;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssetLayer_Asset_AssetCalibration>, I>>(
    base?: I,
  ): AssetLayer_Asset_AssetCalibration {
    return AssetLayer_Asset_AssetCalibration.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssetLayer_Asset_AssetCalibration>, I>>(
    object: I,
  ): AssetLayer_Asset_AssetCalibration {
    const message = createBaseAssetLayer_Asset_AssetCalibration();
    message.xOffset = object.xOffset ?? 0;
    message.yOffset = object.yOffset ?? 0;
    message.ppiX = object.ppiX ?? 0;
    message.ppiY = object.ppiY ?? 0;
    return message;
  },
};

function createBaseFogLayer(): FogLayer {
  return {
    id: "",
    name: "",
    visible: false,
    type: 0,
    lightSources: [],
    obstructionPolygons: [],
    fogPolygons: [],
    fogClearPolygons: [],
  };
}

export const FogLayer = {
  encode(message: FogLayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.visible !== false) {
      writer.uint32(32).bool(message.visible);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    for (const v of message.lightSources) {
      FogLayer_LightSource.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    for (const v of message.obstructionPolygons) {
      FogLayer_Polygon.encode(v!, writer.uint32(58).fork()).ldelim();
    }
    for (const v of message.fogPolygons) {
      FogLayer_Polygon.encode(v!, writer.uint32(66).fork()).ldelim();
    }
    for (const v of message.fogClearPolygons) {
      FogLayer_Polygon.encode(v!, writer.uint32(74).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FogLayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFogLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.visible = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.lightSources.push(FogLayer_LightSource.decode(reader, reader.uint32()));
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.obstructionPolygons.push(FogLayer_Polygon.decode(reader, reader.uint32()));
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.fogPolygons.push(FogLayer_Polygon.decode(reader, reader.uint32()));
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.fogClearPolygons.push(FogLayer_Polygon.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FogLayer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      type: isSet(object.type) ? layer_LayerTypeFromJSON(object.type) : 0,
      lightSources: globalThis.Array.isArray(object?.lightSources)
        ? object.lightSources.map((e: any) => FogLayer_LightSource.fromJSON(e))
        : [],
      obstructionPolygons: globalThis.Array.isArray(object?.obstructionPolygons)
        ? object.obstructionPolygons.map((e: any) => FogLayer_Polygon.fromJSON(e))
        : [],
      fogPolygons: globalThis.Array.isArray(object?.fogPolygons)
        ? object.fogPolygons.map((e: any) => FogLayer_Polygon.fromJSON(e))
        : [],
      fogClearPolygons: globalThis.Array.isArray(object?.fogClearPolygons)
        ? object.fogClearPolygons.map((e: any) => FogLayer_Polygon.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FogLayer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.type !== 0) {
      obj.type = layer_LayerTypeToJSON(message.type);
    }
    if (message.lightSources?.length) {
      obj.lightSources = message.lightSources.map((e) => FogLayer_LightSource.toJSON(e));
    }
    if (message.obstructionPolygons?.length) {
      obj.obstructionPolygons = message.obstructionPolygons.map((e) => FogLayer_Polygon.toJSON(e));
    }
    if (message.fogPolygons?.length) {
      obj.fogPolygons = message.fogPolygons.map((e) => FogLayer_Polygon.toJSON(e));
    }
    if (message.fogClearPolygons?.length) {
      obj.fogClearPolygons = message.fogClearPolygons.map((e) => FogLayer_Polygon.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FogLayer>, I>>(base?: I): FogLayer {
    return FogLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FogLayer>, I>>(object: I): FogLayer {
    const message = createBaseFogLayer();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.visible = object.visible ?? false;
    message.type = object.type ?? 0;
    message.lightSources = object.lightSources?.map((e) => FogLayer_LightSource.fromPartial(e)) || [];
    message.obstructionPolygons = object.obstructionPolygons?.map((e) => FogLayer_Polygon.fromPartial(e)) || [];
    message.fogPolygons = object.fogPolygons?.map((e) => FogLayer_Polygon.fromPartial(e)) || [];
    message.fogClearPolygons = object.fogClearPolygons?.map((e) => FogLayer_Polygon.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFogLayer_LightSource(): FogLayer_LightSource {
  return { position: undefined, brightLightDistance: 0, dimLightDistance: 0, color: undefined };
}

export const FogLayer_LightSource = {
  encode(message: FogLayer_LightSource, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.position !== undefined) {
      Vector2d.encode(message.position, writer.uint32(10).fork()).ldelim();
    }
    if (message.brightLightDistance !== 0) {
      writer.uint32(21).float(message.brightLightDistance);
    }
    if (message.dimLightDistance !== 0) {
      writer.uint32(29).float(message.dimLightDistance);
    }
    if (message.color !== undefined) {
      FogLayer_LightSource_Color.encode(message.color, writer.uint32(34).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FogLayer_LightSource {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFogLayer_LightSource();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.position = Vector2d.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 21) {
            break;
          }

          message.brightLightDistance = reader.float();
          continue;
        case 3:
          if (tag !== 29) {
            break;
          }

          message.dimLightDistance = reader.float();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.color = FogLayer_LightSource_Color.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FogLayer_LightSource {
    return {
      position: isSet(object.position) ? Vector2d.fromJSON(object.position) : undefined,
      brightLightDistance: isSet(object.brightLightDistance) ? globalThis.Number(object.brightLightDistance) : 0,
      dimLightDistance: isSet(object.dimLightDistance) ? globalThis.Number(object.dimLightDistance) : 0,
      color: isSet(object.color) ? FogLayer_LightSource_Color.fromJSON(object.color) : undefined,
    };
  },

  toJSON(message: FogLayer_LightSource): unknown {
    const obj: any = {};
    if (message.position !== undefined) {
      obj.position = Vector2d.toJSON(message.position);
    }
    if (message.brightLightDistance !== 0) {
      obj.brightLightDistance = message.brightLightDistance;
    }
    if (message.dimLightDistance !== 0) {
      obj.dimLightDistance = message.dimLightDistance;
    }
    if (message.color !== undefined) {
      obj.color = FogLayer_LightSource_Color.toJSON(message.color);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FogLayer_LightSource>, I>>(base?: I): FogLayer_LightSource {
    return FogLayer_LightSource.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FogLayer_LightSource>, I>>(object: I): FogLayer_LightSource {
    const message = createBaseFogLayer_LightSource();
    message.position = (object.position !== undefined && object.position !== null)
      ? Vector2d.fromPartial(object.position)
      : undefined;
    message.brightLightDistance = object.brightLightDistance ?? 0;
    message.dimLightDistance = object.dimLightDistance ?? 0;
    message.color = (object.color !== undefined && object.color !== null)
      ? FogLayer_LightSource_Color.fromPartial(object.color)
      : undefined;
    return message;
  },
};

function createBaseFogLayer_LightSource_Color(): FogLayer_LightSource_Color {
  return { r: 0, g: 0, b: 0, a: 0 };
}

export const FogLayer_LightSource_Color = {
  encode(message: FogLayer_LightSource_Color, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.r !== 0) {
      writer.uint32(8).uint32(message.r);
    }
    if (message.g !== 0) {
      writer.uint32(16).uint32(message.g);
    }
    if (message.b !== 0) {
      writer.uint32(24).uint32(message.b);
    }
    if (message.a !== 0) {
      writer.uint32(32).uint32(message.a);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FogLayer_LightSource_Color {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFogLayer_LightSource_Color();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.r = reader.uint32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.g = reader.uint32();
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.b = reader.uint32();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.a = reader.uint32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FogLayer_LightSource_Color {
    return {
      r: isSet(object.r) ? globalThis.Number(object.r) : 0,
      g: isSet(object.g) ? globalThis.Number(object.g) : 0,
      b: isSet(object.b) ? globalThis.Number(object.b) : 0,
      a: isSet(object.a) ? globalThis.Number(object.a) : 0,
    };
  },

  toJSON(message: FogLayer_LightSource_Color): unknown {
    const obj: any = {};
    if (message.r !== 0) {
      obj.r = Math.round(message.r);
    }
    if (message.g !== 0) {
      obj.g = Math.round(message.g);
    }
    if (message.b !== 0) {
      obj.b = Math.round(message.b);
    }
    if (message.a !== 0) {
      obj.a = Math.round(message.a);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FogLayer_LightSource_Color>, I>>(base?: I): FogLayer_LightSource_Color {
    return FogLayer_LightSource_Color.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FogLayer_LightSource_Color>, I>>(object: I): FogLayer_LightSource_Color {
    const message = createBaseFogLayer_LightSource_Color();
    message.r = object.r ?? 0;
    message.g = object.g ?? 0;
    message.b = object.b ?? 0;
    message.a = object.a ?? 0;
    return message;
  },
};

function createBaseFogLayer_Polygon(): FogLayer_Polygon {
  return { type: 0, verticies: [], visibleOnTable: false };
}

export const FogLayer_Polygon = {
  encode(message: FogLayer_Polygon, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    for (const v of message.verticies) {
      Vector2d.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    if (message.visibleOnTable !== false) {
      writer.uint32(24).bool(message.visibleOnTable);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): FogLayer_Polygon {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFogLayer_Polygon();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.verticies.push(Vector2d.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.visibleOnTable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FogLayer_Polygon {
    return {
      type: isSet(object.type) ? fogLayer_Polygon_PolygonTypeFromJSON(object.type) : 0,
      verticies: globalThis.Array.isArray(object?.verticies)
        ? object.verticies.map((e: any) => Vector2d.fromJSON(e))
        : [],
      visibleOnTable: isSet(object.visibleOnTable) ? globalThis.Boolean(object.visibleOnTable) : false,
    };
  },

  toJSON(message: FogLayer_Polygon): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = fogLayer_Polygon_PolygonTypeToJSON(message.type);
    }
    if (message.verticies?.length) {
      obj.verticies = message.verticies.map((e) => Vector2d.toJSON(e));
    }
    if (message.visibleOnTable !== false) {
      obj.visibleOnTable = message.visibleOnTable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FogLayer_Polygon>, I>>(base?: I): FogLayer_Polygon {
    return FogLayer_Polygon.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FogLayer_Polygon>, I>>(object: I): FogLayer_Polygon {
    const message = createBaseFogLayer_Polygon();
    message.type = object.type ?? 0;
    message.verticies = object.verticies?.map((e) => Vector2d.fromPartial(e)) || [];
    message.visibleOnTable = object.visibleOnTable ?? false;
    return message;
  },
};

function createBaseMarkerLayer(): MarkerLayer {
  return { id: "", name: "", visible: false, type: 0, markers: [] };
}

export const MarkerLayer = {
  encode(message: MarkerLayer, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.name !== "") {
      writer.uint32(26).string(message.name);
    }
    if (message.visible !== false) {
      writer.uint32(32).bool(message.visible);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    for (const v of message.markers) {
      Marker.encode(v!, writer.uint32(50).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): MarkerLayer {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarkerLayer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.visible = reader.bool();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.markers.push(Marker.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MarkerLayer {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      visible: isSet(object.visible) ? globalThis.Boolean(object.visible) : false,
      type: isSet(object.type) ? layer_LayerTypeFromJSON(object.type) : 0,
      markers: globalThis.Array.isArray(object?.markers) ? object.markers.map((e: any) => Marker.fromJSON(e)) : [],
    };
  },

  toJSON(message: MarkerLayer): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.visible !== false) {
      obj.visible = message.visible;
    }
    if (message.type !== 0) {
      obj.type = layer_LayerTypeToJSON(message.type);
    }
    if (message.markers?.length) {
      obj.markers = message.markers.map((e) => Marker.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MarkerLayer>, I>>(base?: I): MarkerLayer {
    return MarkerLayer.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MarkerLayer>, I>>(object: I): MarkerLayer {
    const message = createBaseMarkerLayer();
    message.id = object.id ?? "";
    message.name = object.name ?? "";
    message.visible = object.visible ?? false;
    message.type = object.type ?? 0;
    message.markers = object.markers?.map((e) => Marker.fromPartial(e)) || [];
    return message;
  },
};

function createBaseMarker(): Marker {
  return { id: "", asset: undefined };
}

export const Marker = {
  encode(message: Marker, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.asset !== undefined) {
      AssetLayer_Asset.encode(message.asset, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): Marker {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMarker();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.asset = AssetLayer_Asset.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Marker {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      asset: isSet(object.asset) ? AssetLayer_Asset.fromJSON(object.asset) : undefined,
    };
  },

  toJSON(message: Marker): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.asset !== undefined) {
      obj.asset = AssetLayer_Asset.toJSON(message.asset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Marker>, I>>(base?: I): Marker {
    return Marker.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Marker>, I>>(object: I): Marker {
    const message = createBaseMarker();
    message.id = object.id ?? "";
    message.asset = (object.asset !== undefined && object.asset !== null)
      ? AssetLayer_Asset.fromPartial(object.asset)
      : undefined;
    return message;
  },
};

function createBaseSceneExport(): SceneExport {
  return { scene: undefined, files: [] };
}

export const SceneExport = {
  encode(message: SceneExport, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.scene !== undefined) {
      Scene.encode(message.scene, writer.uint32(10).fork()).ldelim();
    }
    for (const v of message.files) {
      SceneExport_File.encode(v!, writer.uint32(18).fork()).ldelim();
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneExport {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneExport();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.scene = Scene.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.files.push(SceneExport_File.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneExport {
    return {
      scene: isSet(object.scene) ? Scene.fromJSON(object.scene) : undefined,
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => SceneExport_File.fromJSON(e)) : [],
    };
  },

  toJSON(message: SceneExport): unknown {
    const obj: any = {};
    if (message.scene !== undefined) {
      obj.scene = Scene.toJSON(message.scene);
    }
    if (message.files?.length) {
      obj.files = message.files.map((e) => SceneExport_File.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneExport>, I>>(base?: I): SceneExport {
    return SceneExport.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneExport>, I>>(object: I): SceneExport {
    const message = createBaseSceneExport();
    message.scene = (object.scene !== undefined && object.scene !== null) ? Scene.fromPartial(object.scene) : undefined;
    message.files = object.files?.map((e) => SceneExport_File.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSceneExport_File(): SceneExport_File {
  return { id: "", payload: new Uint8Array(0), mediaType: "" };
}

export const SceneExport_File = {
  encode(message: SceneExport_File, writer: _m0.Writer = _m0.Writer.create()): _m0.Writer {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.payload.length !== 0) {
      writer.uint32(18).bytes(message.payload);
    }
    if (message.mediaType !== "") {
      writer.uint32(26).string(message.mediaType);
    }
    return writer;
  },

  decode(input: _m0.Reader | Uint8Array, length?: number): SceneExport_File {
    const reader = input instanceof _m0.Reader ? input : _m0.Reader.create(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSceneExport_File();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.payload = reader.bytes();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.mediaType = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skipType(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SceneExport_File {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(0),
      mediaType: isSet(object.mediaType) ? globalThis.String(object.mediaType) : "",
    };
  },

  toJSON(message: SceneExport_File): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.payload.length !== 0) {
      obj.payload = base64FromBytes(message.payload);
    }
    if (message.mediaType !== "") {
      obj.mediaType = message.mediaType;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SceneExport_File>, I>>(base?: I): SceneExport_File {
    return SceneExport_File.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SceneExport_File>, I>>(object: I): SceneExport_File {
    const message = createBaseSceneExport_File();
    message.id = object.id ?? "";
    message.payload = object.payload ?? new Uint8Array(0);
    message.mediaType = object.mediaType ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(long: Long): number {
  if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return long.toNumber();
}

if (_m0.util.Long !== Long) {
  _m0.util.Long = Long as any;
  _m0.configure();
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}
